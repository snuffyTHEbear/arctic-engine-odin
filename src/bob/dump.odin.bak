package bob

//import "core:math/rand"
//import "core:math/linalg"
import "../core"
import "../entities"
import "../gfx"
import "../gfx/utils"
import "../states"
import "../world"
import "core:fmt"
import "core:math"
import rl "vendor:raylib"
import rlgl "vendor:raylib/rlgl"

SCREEN_WIDTH :: 1920
SCREEN_HEIGHT :: 1080
TARGET_FPS :: 144
MAP_SIZE_X :: 25
MAP_SIZE_Y :: 25
MAP_SIZE :: MAP_SIZE_X * MAP_SIZE_Y

SPEED :: 10.0
GRAVITY :: 40.0
JUMP_FORCE :: 15.0

TILE_SIZE :: 64
TILE_OFFSET :: TILE_SIZE / 2

SHADER_VS :: "./assets/shaders/iso_depth.vs"
SHADER_FS :: "./assets/shaders/iso_depth.fs"

BlockIndex :: struct {
	curr_idx: int,
	prev_idx: int,
	next_idx: int,
}

main :: proc() {

	rl.InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "Arctic-Engine")

	rl.SetTargetFPS(TARGET_FPS)

	defer rl.CloseWindow()

	rts_cam := init_camera(SCREEN_WIDTH, SCREEN_HEIGHT)

	shader := rl.LoadShader(SHADER_VS, SHADER_FS)
	defer rl.UnloadShader(shader)

	pathfinder := core.init_pathfinder(MAP_SIZE_X, MAP_SIZE_Y)
	defer core.destroy_pathfinder(&pathfinder)

	start_pos := core.iso_to_screen(0, 0)

	controls := states.init_controls()

	bob := entities.Unit {
		grid_pos   = {1, 1},
		visual_pos = {start_pos.x, start_pos.y},
	}

	map_height_loc := rl.GetShaderLocation(shader, "mapHeight")
	if map_height_loc == -1 {
		fmt.println("Failed to get mapHeight uniform location in shader")
	}
	map_h_val: f32 = MAP_SIZE * TILE_SIZE + 2000.0
	rl.SetShaderValue(shader, map_height_loc, &map_h_val, .FLOAT)

	atlas := gfx.init_atlas()
	defer gfx.destroy_atlas(&atlas)

	iso_world := world.init_map(MAP_SIZE_X, MAP_SIZE_Y)
	defer world.destroy_map(&iso_world)

	fmt.println("Engine started, Map Initialized")

	for !rl.WindowShouldClose() {
		dt := rl.GetFrameTime()
		time := f32(rl.GetTime())
		update_camera(&rts_cam)
		states.update_controls(&controls, dt)


		mouse_screen_pos := rl.GetMousePosition()
		mouse_world := rl.GetScreenToWorld2D(mouse_screen_pos, rts_cam.rl_camera)
		hover_x, hover_y := core.screen_to_iso(mouse_world)

		if rl.IsKeyPressed(.F5) {
			core.save_map(&iso_world, "level_data.bin")
		}

		if rl.IsKeyPressed(.F6) {
			world.destroy_map(&iso_world)
			iso_world = core.load_map("level_data.bin")

			new_pixel_height := f32(iso_world.height * 32) + 2000.0
			rl.SetShaderValue(shader, map_height_loc, &new_pixel_height, .FLOAT)

			// if (bob.grid_pos.x >= iso_world.width || bob.grid_pos.y >= iso_world.height) {
			// 	bob.grid_pos = core.Point{0, 0}
			// 	bob.visual_pos = core.iso_to_screen(0, 0)
			// 	bob.current_height = iso_world.tile_heights[0]
			// 	clear(&bob.path)
			// }
		}

		if !controls.paused {

		}

		states.update_simulation(&iso_world, &controls, time)

		bob.pos = bob.pos + (bob.input_dir * SPEED * dt)
		bob.pos.x = rl.Clamp(bob.pos.x, 0.0, f32(iso_world.width) - 1.0)
		bob.pos.y = rl.Clamp(bob.pos.y, 0.0, f32(iso_world.height) - 1.0)

		gx, gy := int(bob.pos.x + 0.5), int(bob.pos.y + 0.5)
		idx := world.get_tile_index(&iso_world, gx, gy)

		ground_height := f32(0.0)
		if idx != -1 {
			ground_height = iso_world.tile_heights[idx]
		}

		bob.height = ground_height

		bob.visual_pos = core.iso_to_screen_float(bob.pos.x, bob.pos.y)

		// if bob.is_grounded {
		// 	bob.height = ground_height
		// 	bob.velocity_z = 0.0
		// } else {
		// 	bob.velocity_z -= GRAVITY * dt
		// 	bob.height += bob.velocity_z * dt
		// 	if bob.height <= ground_height {
		// 		bob.height = ground_height
		// 		bob.velocity_z = 0.0
		// 		bob.is_grounded = true
		// 	}
		// }

		// Input
		// if rl.IsMouseButtonPressed(.LEFT) || rl.IsMouseButtonPressed(.RIGHT)
		// {
		//     gx, gy := hover_x, hover_y
		//     if gx >= 0 && gx < world.width && gy >= 0 && gy < world.height
		//     {
		//         idx := get_tile_index(&world, gx, gy)
		//         fmt.println("Clicked Tile: ", gx, ", ", gy, " Index: ", idx)

		//         if rl.IsMouseButtonPressed(.LEFT)
		//         {
		//             //Add a height cap for when it reaches e.g. 100 it resets to 0
		//             world.tile_heights[idx] += 10.0
		//             if world.tile_heights[idx] > 100.0
		//             {
		//                 world.tile_heights[idx] = 0.0
		//             }
		//         }
		//         else if rl.IsMouseButtonPressed(.RIGHT)
		//         {
		//             if len(bob.path) > 0 {
		//                 delete(bob.path)
		//             }

		//             target := Point{gx, gy}
		//             bob.path = find_path(&pathfinder, &world, bob.grid_pos, target)

		//             if bob.path == nil{
		//                 fmt.println("No path found!")
		//             } else {
		//                 fmt.println("Path found with ", len(bob.path), " nodes.")
		//             }
		//         }
		//     }
		// }
		// Movement
		// if len(bob.path) > 0{
		//     next_step := bob.path[0]

		//     if next_step == bob.grid_pos{
		//         ordered_remove(&bob.path, 0)
		//     }
		//     else
		//     {
		//         target_world := iso_to_screen(next_step.x, next_step.y)
		//         next_idx := get_tile_index(&world, next_step.x, next_step.y)
		//         next_height := world.tile_heights[next_idx]
		//         target_vis := rl.Vector2{target_world.x, target_world.y - next_height}

		//         dist := rl.Vector2Distance(bob.visual_pos, target_vis)
		//         //move_speed := 200.0 // Units per second
		//         if dist < 2.0{
		//             bob.grid_pos = next_step // snap
		//             bob.current_height = next_height
		//         }
		//         else
		//         {
		//             bob.visual_pos = linalg.lerp(bob.visual_pos, target_vis, 30.0 * dt)
		//             bob.current_height = linalg.lerp(bob.current_height, next_height, 30.0 * dt)
		//         }
		//     }
		// }
		// Drawing
		rl.BeginDrawing()
		rl.ClearBackground(rl.BROWN)
		//rlgl.ClearColor(1,1,1,1)
		//rlgl.Clear(rlgl.COLOR_BUFFER_BIT | rlgl.DEPTH_BUFFER_BIT)
		rlgl.ClearScreenBuffers()
		//rl.rlClearScreenBuffers()
		current_theme := utils.THEMES[controls.palette_idx]

		rl.BeginMode2D(rts_cam.rl_camera)
		rlgl.EnableDepthTest()
		rl.BeginShaderMode(shader)

		min_x, min_y, max_x, max_y := core.get_visible_tiles(
			rts_cam.rl_camera,
			iso_world.width,
			iso_world.height,
		)

		for y := max_y; y >= min_y; y -= 1 {
			for x := max_x; x >= min_x; x -= 1 {
				idx = world.get_tile_index(&iso_world, x, y)
				h := iso_world.tile_heights[idx]

				min_h := -controls.amplitude
				max_h := controls.amplitude
				range := max_h - min_h

				if range < 1.0 do range = 1.0

				t := (h - min_h) / range
				t = rl.Clamp(t, 0.0, 1.0)
				t = math.floor_f32(t * controls.steps) / controls.steps

				tile_colour := rl.ColorLerp(current_theme.low, current_theme.high, t)

				tile_type := iso_world.tile_ids[idx]
				rect := atlas.sprites[tile_type]

				pos := core.iso_to_screen(x, y)

				visual_pos := rl.Vector2{pos.x - TILE_OFFSET, pos.y - TILE_OFFSET - h}

				s_idx := world.get_tile_index(&iso_world, x, y + 1)
				s_h := f32(-10.0)
				if s_idx != -1 do s_h = iso_world.tile_heights[s_idx]

				if h > s_h {
					wall_colour := rl.ColorBrightness(tile_colour, -0.2) //rl.Color{200, 200, 200, 255}
					gfx.draw_wall(
						atlas.texture,
						rect,
						pos,
						h,
						s_h,
						gfx.WALL_TYPES.SOUTH_FACE,
						wall_colour,
					)
				}

				e_idx := world.get_tile_index(&iso_world, x + 1, y)
				e_h := f32(-10.0)
				if e_idx != -1 do e_h = iso_world.tile_heights[e_idx]

				if h > e_h {
					wall_colour := rl.ColorBrightness(tile_colour, -0.4) //rl.Color{150, 150, 150, 255}
					gfx.draw_wall(
						atlas.texture,
						rect,
						pos,
						h,
						e_h,
						gfx.WALL_TYPES.EAST_FACE,
						wall_colour,
					)
				}

				gfx.draw_tile(atlas.texture, rect, visual_pos, pos.y, tile_colour)
			}
		}
		//When bob moves lift him?
		bob_sort_y := bob.visual_pos.y + bob.height // + 1.0
		//bob_sort_y += 1.0
		bob_rect := atlas.sprites[gfx.TileType.BOB]

		//screen_pos := iso_to_screen(int(bob.pos.x), int(bob.pos.y))
		screen_x := (bob.pos.x - bob.pos.y) * (TILE_SIZE / 2.0)
		screen_y := (bob.pos.x + bob.pos.y) * (TILE_SIZE / 4.0)
		bob.visual_pos = rl.Vector2{screen_x, screen_y - bob.height}

		//rl.Rectangle{0, 0, TILE_SIZE, TILE_SIZE}
		gfx.draw_tile(
			atlas.texture,
			bob_rect,
			{bob.visual_pos.x - TILE_OFFSET, bob.visual_pos.y - TILE_OFFSET},
			bob_sort_y,
			rl.WHITE,
		)

		rl.EndShaderMode()

		//DEBUG LINES
		if len(bob.path) > 0 {
			rlgl.DisableDepthTest()
			for i in 0 ..< len(bob.path) - 1 {

				p1 := bob.path[i]
				p2 := bob.path[i + 1]

				pos1 := core.iso_to_screen(p1.x, p1.y)
				pos2 := core.iso_to_screen(p2.x, p2.y)

				rl.DrawLineV({pos1.x, pos1.y - 10}, {pos2.x, pos2.y - 10}, rl.GREEN)
			}
			rlgl.EnableDepthTest()
		}

		rlgl.DisableDepthTest()
		rl.EndMode2D()

		// rl.DrawRectangle(5, 5,      450,    250, rl.Fade(rl.BLACK, 0.7))
		// rl.DrawRectangleLines(5,5,  450,    250,rl.BEIGE)
		start_y :: 15
		step_y :: 25

		rl.DrawText(
			rl.TextFormat("MODE (Tab): %v", controls.active_type),
			15,
			start_y,
			20,
			rl.GREEN,
		)
		rl.DrawText(
			rl.TextFormat("Speed (1/3): %.2f", controls.speed),
			15,
			start_y + step_y * 1,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Freq (7/9): %.2f", controls.frequency),
			15,
			start_y + step_y * 2,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Amp (Up/Dn): %.2f", controls.amplitude),
			15,
			start_y + step_y * 3,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Hover: %i, %i", i32(hover_x), i32(hover_y)),
			15,
			start_y + step_y * 4,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Right/Middle Click to Pan, Wheel to zoom."),
			15,
			start_y + step_y * 5,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Tiles Drawn: %i", (max_x - min_x) * (max_y - min_y)),
			15,
			start_y + step_y * 6,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Steps (-/+): %.2f", controls.steps),
			15,
			start_y + step_y * 7,
			20,
			rl.WHITE,
		)
		rl.DrawText(
			rl.TextFormat("Theme (C): %v", current_theme.name),
			15,
			start_y + step_y * 8,
			20,
			rl.WHITE,
		)
		rl.DrawFPS(SCREEN_WIDTH - 100, 10)

		rl.EndDrawing()
	}

}
